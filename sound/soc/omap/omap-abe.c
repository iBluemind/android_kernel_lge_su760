#undef DEBUG#include <linux/init.h>#include <linux/module.h>#include <linux/device.h>#include <linux/slab.h>#include <linux/platform_device.h>#include <linux/workqueue.h>#include <linux/delay.h>#include <sound/core.h>#include <sound/pcm.h>#include <sound/pcm_params.h>#include <sound/initval.h>#include <sound/soc.h>#include <sound/soc-dapm.h>#include <plat/control.h>#include <plat/dma-44xx.h>#include <plat/dma.h>#include "omap-mcpdm.h"#include "omap-pcm.h"#include "omap-abe.h"#include "omap-abe-dsp.h"#include "abe/abe_main.h"#include "omap-mcbsp.h"#define OMAP_ABE_FORMATS	(SNDRV_PCM_FMTBIT_S32_LE)#define NUM_ABE_FRONTENDS		7#define NUM_ABE_BACKENDS		11enum dai_status {	DAI_STOPPED = 0,	DAI_STARTED,};struct omap_abe_data {	int be_active[NUM_ABE_BACKENDS][2];	int trigger_active[NUM_ABE_BACKENDS][2];	struct clk *clk;	struct workqueue_struct *workqueue;	struct platform_device *pdev;	struct snd_pcm_substream *modem_substream[2];	struct snd_soc_dai *modem_dai;	enum dai_status dmic_status[3];	enum dai_status pdm_dl_status[3];	enum dai_status pdm_ul_status;	int dmic_ref_cnt[3];	int pdm_dl_ref_cnt[3];	int pdm_ul_ref_cnt;	int abe_temp_disable_port[20];};static struct omap_abe_data abe_data;static void capture_trigger(struct snd_pcm_substream *substream, int cmd);static void playback_trigger(struct snd_pcm_substream *substream, int cmd);static DEFINE_MUTEX(fe_mutex);static struct omap_pcm_dma_data omap_abe_dai_dma_params[7][2] = {{	{		.name = "Media Playback",		.dma_req = OMAP44XX_DMA_ABE_REQ_0,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},	{		.name = "Media Capture1",		.dma_req = OMAP44XX_DMA_ABE_REQ_3,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},},{	{},	{		.name = "Media Capture2",		.dma_req = OMAP44XX_DMA_ABE_REQ_4,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},},{	{		.name = "Voice Playback",		.dma_req = OMAP44XX_DMA_ABE_REQ_1,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},	{		.name = "Voice Capture",		.dma_req = OMAP44XX_DMA_ABE_REQ_2,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},},{	{		.name = "Tones Playback",		.dma_req = OMAP44XX_DMA_ABE_REQ_5,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},{},},{	{		.name = "Vibra Playback",		.dma_req = OMAP44XX_DMA_ABE_REQ_6,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},{},},{	{		.name = "MODEM Playback",		.dma_req = OMAP44XX_DMA_ABE_REQ_1,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},	{		.name = "MODEM Capture",		.dma_req = OMAP44XX_DMA_ABE_REQ_2,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},},{	{		.name = "Low Power Playback",		.dma_req = OMAP44XX_DMA_ABE_REQ_0,		.data_type = OMAP_DMA_DATA_TYPE_S32,		.sync_mode = OMAP_DMA_SYNC_PACKET,	},{},},};static inline int be_get_active(struct snd_soc_pcm_runtime *be_rtd, int stream){	return abe_data.be_active[be_rtd->dai_link->be_id][stream];}static inline void be_inc_active(struct snd_soc_pcm_runtime *be_rtd, int stream){	abe_data.be_active[be_rtd->dai_link->be_id][stream]++;}static inline void be_dec_active(struct snd_soc_pcm_runtime *be_rtd, int stream){	abe_data.be_active[be_rtd->dai_link->be_id][stream]--;}static inline int be_is_pending(struct snd_soc_pcm_runtime *be_rtd, int stream){	return abe_data.be_active[be_rtd->dai_link->be_id][stream] == 1 ? 1 : 0;}static inline int be_is_running(struct snd_soc_pcm_runtime *be_rtd, int stream){	return abe_data.be_active[be_rtd->dai_link->be_id][stream] >= 1 ? 1 : 0;}static inline int trigger_get_active(struct snd_soc_pcm_runtime *be_rtd,					int stream){	return abe_data.trigger_active[be_rtd->dai_link->be_id][stream];}static inline void trigger_inc_active(struct snd_soc_pcm_runtime *be_rtd,					int stream){	abe_data.trigger_active[be_rtd->dai_link->be_id][stream]++;}static inline void trigger_dec_active(struct snd_soc_pcm_runtime *be_rtd,					int stream){	abe_data.trigger_active[be_rtd->dai_link->be_id][stream]--;}static inline int trigger_is_pending(struct snd_soc_pcm_runtime *be_rtd,					int stream){	return abe_data.trigger_active[be_rtd->dai_link->be_id][stream] == 1 ? 1 : 0;}static inline int pdm_ready(struct omap_abe_data *abe){	int i;	for (i = 0; i < 3; i++) {		if (abe->pdm_dl_status[i] == DAI_STARTED)			return 0;	}	return 1;}static inline int dmic_ready(struct omap_abe_data *abe){	int i;	for (i = 0; i < 3; i++) {		if (abe->dmic_status[i] == DAI_STARTED)			return 0;	}	return 1;}static int modem_get_dai(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *modem_rtd;	int stream;		if( substream->stream == SNDRV_PCM_STREAM_CAPTURE )		stream = SNDRV_PCM_STREAM_PLAYBACK;	else		stream = SNDRV_PCM_STREAM_CAPTURE;		abe_data.modem_substream[substream->stream] =			snd_soc_get_dai_substream(rtd->card,					OMAP_ABE_BE_MM_EXT1, stream);	if (abe_data.modem_substream[substream->stream] == NULL)		return -ENODEV;	modem_rtd = abe_data.modem_substream[substream->stream]->private_data;	abe_data.modem_dai = modem_rtd->cpu_dai;	return 0;}static int abe_fe_startup(struct snd_pcm_substream *substream,			struct snd_soc_dai *dai){	int ret = 0;#if 0	snd_pcm_hw_constraint_list(substream->runtime, 0,				SNDRV_PCM_HW_PARAM_RATE,				priv->sysclk_constraints);#endif	if (dai->id == ABE_FRONTEND_DAI_MODEM) {		ret = modem_get_dai(substream);		if (ret < 0) {			dev_err(dai->dev, "failed to get MODEM DAI\n");			return ret;		}		dev_dbg(abe_data.modem_dai->dev, "%s: MODEM stream %d\n",				__func__, substream->stream);		ret = snd_soc_dai_startup(abe_data.modem_substream[substream->stream],				abe_data.modem_dai);		if (ret < 0) {			dev_err(abe_data.modem_dai->dev, "failed to open DAI %d\n", ret);			return ret;		}	}	return ret;}static int abe_fe_hw_params(struct snd_pcm_substream *substream,			struct snd_pcm_hw_params *params,			struct snd_soc_dai *dai){	abe_data_format_t format;	abe_dma_t dma_sink;	abe_dma_t dma_params;	int ret;	memset(&dma_params, 0, sizeof(abe_dma_t));	memset(&dma_sink, 0, sizeof(abe_dma_t));	memset(&format, 0, sizeof(abe_data_format_t));	switch (params_channels(params)) {	case 1:		if (params_format(params) == SNDRV_PCM_FORMAT_S16_LE)			format.samp_format = MONO_RSHIFTED_16;		else			format.samp_format = MONO_MSB;		break;	case 2:		if (params_format(params) == SNDRV_PCM_FORMAT_S16_LE)			format.samp_format = STEREO_16_16;		else			format.samp_format = STEREO_MSB;		break;	case 3:		format.samp_format = THREE_MSB;		break;	case 4:		format.samp_format = FOUR_MSB;		break;	case 5:		format.samp_format = FIVE_MSB;		break;	case 6 :		format.samp_format = SIX_MSB;		break;	case 7 :		format.samp_format = SEVEN_MSB;		break;	case 8:		format.samp_format = EIGHT_MSB;		break;	default:		dev_err(dai->dev, "%d channels not supported",			params_channels(params));		return -EINVAL;	}	format.f = params_rate(params);	switch (dai->id) {	case ABE_FRONTEND_DAI_MEDIA:		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {			abe_connect_cbpr_dmareq_port(MM_DL_PORT, &format, ABE_CBPR0_IDX,					&dma_sink);			abe_read_port_address(MM_DL_PORT, &dma_params);		} else {			abe_connect_cbpr_dmareq_port(MM_UL_PORT, &format,  ABE_CBPR3_IDX,					&dma_sink);			abe_read_port_address(MM_UL_PORT, &dma_params);		}        break;	case ABE_FRONTEND_DAI_LP_MEDIA:		return 0;        break;	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)			return -EINVAL;		else {			abe_connect_cbpr_dmareq_port(MM_UL2_PORT, &format,  ABE_CBPR4_IDX,					&dma_sink);			abe_read_port_address(MM_UL2_PORT, &dma_params);		}        break;	case ABE_FRONTEND_DAI_VOICE:		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {			abe_connect_cbpr_dmareq_port(VX_DL_PORT, &format, ABE_CBPR1_IDX,					&dma_sink);			abe_read_port_address(VX_DL_PORT, &dma_params);		} else {			abe_connect_cbpr_dmareq_port(VX_UL_PORT, &format,  ABE_CBPR2_IDX,					&dma_sink);			abe_read_port_address(VX_UL_PORT, &dma_params);		}        break;	case ABE_FRONTEND_DAI_TONES:		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {			abe_connect_cbpr_dmareq_port(TONES_DL_PORT, &format, ABE_CBPR5_IDX,					&dma_sink);			abe_read_port_address(TONES_DL_PORT, &dma_params);		} else			return -EINVAL;        break;	case ABE_FRONTEND_DAI_VIBRA:		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {			abe_connect_cbpr_dmareq_port(VIB_DL_PORT, &format, ABE_CBPR6_IDX,					&dma_sink);			abe_read_port_address(VIB_DL_PORT, &dma_params);		} else			return -EINVAL;		break;	case ABE_FRONTEND_DAI_MODEM:		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {						format.samp_format = MONO_RSHIFTED_16;			abe_connect_serial_port(VX_DL_PORT, &format, MCBSP2_RX);			abe_read_port_address(VX_DL_PORT, &dma_params);		} else {						format.samp_format = MONO_RSHIFTED_16;			abe_connect_serial_port(VX_UL_PORT, &format, MCBSP2_TX);			abe_read_port_address(VX_UL_PORT, &dma_params);		}        break;	}	omap_abe_dai_dma_params[dai->id][substream->stream].port_addr =			(unsigned long)dma_params.data;	omap_abe_dai_dma_params[dai->id][substream->stream].packet_size =			dma_params.iter;	if (dai->id == ABE_FRONTEND_DAI_MODEM) {				ret = snd_soc_dai_set_fmt(abe_data.modem_dai,					  SND_SOC_DAIFMT_I2S |					  SND_SOC_DAIFMT_NB_NF |					  SND_SOC_DAIFMT_CBM_CFM);		if (ret < 0) {			printk(KERN_ERR "can't set cpu DAI configuration\n");			return ret;		}		snd_soc_dai_set_dma_data(abe_data.modem_dai, substream,				&omap_abe_dai_dma_params[dai->id][substream->stream]);		dev_dbg(abe_data.modem_dai->dev, "%s: MODEM stream %d\n",				__func__, substream->stream);		ret = snd_soc_dai_set_sysclk(abe_data.modem_dai, OMAP_MCBSP_SYSCLK_CLKX_EXT, 0, SND_SOC_CLOCK_IN);		ret = snd_soc_dai_hw_params(abe_data.modem_substream[substream->stream],				params, abe_data.modem_dai);				if (ret < 0)			dev_err(abe_data.modem_dai->dev, "MODEM hw_params failed\n");		return ret;	}	snd_soc_dai_set_dma_data(dai, substream,				&omap_abe_dai_dma_params[dai->id][substream->stream]);	return 0;}static int abe_fe_prepare(struct snd_pcm_substream *substream,				  struct snd_soc_dai *dai){	int ret = 0;	if (dai->id == ABE_FRONTEND_DAI_MODEM) {		ret = snd_soc_dai_prepare(abe_data.modem_substream[substream->stream],				abe_data.modem_dai);		dev_dbg(abe_data.modem_dai->dev, "%s: MODEM stream %d\n",				__func__, substream->stream);		if (ret < 0) {			dev_err(abe_data.modem_dai->dev, "MODEM prepare failed\n");			return ret;		}	}	return ret;}static int abe_fe_trigger(struct snd_pcm_substream *substream,				  int cmd, struct snd_soc_dai *dai){	int ret = 0;	if (dai->id == ABE_FRONTEND_DAI_MODEM) {		udelay(500);				dev_dbg(abe_data.modem_dai->dev, "%s: MODEM stream %d cmd %d\n",				__func__, substream->stream, cmd);		ret = snd_soc_dai_trigger(abe_data.modem_substream[substream->stream],				cmd, abe_data.modem_dai);		if (ret < 0) {			dev_err(abe_data.modem_dai->dev, "MODEM trigger failed\n");			return ret;		}	}	return ret;}static int abe_fe_hw_free(struct snd_pcm_substream *substream,				  struct snd_soc_dai *dai){	int ret = 0;	if (dai->id == ABE_FRONTEND_DAI_MODEM) {		dev_dbg(abe_data.modem_dai->dev, "%s: MODEM stream %d\n",				__func__, substream->stream);		ret = snd_soc_dai_hw_free(abe_data.modem_substream[substream->stream],				abe_data.modem_dai);		if (ret < 0) {			dev_err(abe_data.modem_dai->dev, "MODEM hw_free failed\n");			return ret;		}	}	return ret;}static void abe_fe_shutdown(struct snd_pcm_substream *substream,				struct snd_soc_dai *dai){	if (dai->id == ABE_FRONTEND_DAI_MODEM) {		dev_dbg(abe_data.modem_dai->dev, "%s: MODEM stream %d\n",				__func__, substream->stream);		snd_soc_dai_shutdown(abe_data.modem_substream[substream->stream],				abe_data.modem_dai);	}}static void abe_be_dapm(struct snd_soc_pcm_runtime *rtd,		int id, int stream, int cmd){	dev_dbg(&rtd->dev, "%s: id %d stream %d cmd %d\n",			__func__, id, stream, cmd);	switch (id) {	case ABE_FRONTEND_DAI_MEDIA:	case ABE_FRONTEND_DAI_LP_MEDIA:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, stream, "Multimedia Playback",cmd);		else			snd_soc_dapm_stream_event(rtd, stream, "Multimedia Capture1",cmd);		break;	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:		snd_soc_dapm_stream_event(rtd, stream, "Multimedia Capture2",cmd);		break;	case ABE_FRONTEND_DAI_VOICE:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, stream, "Voice Playback",cmd);		else			snd_soc_dapm_stream_event(rtd, stream, "Voice Capture",cmd);		break;	case ABE_FRONTEND_DAI_TONES:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, stream, "Tones Playback",cmd);		break;	case ABE_FRONTEND_DAI_VIBRA:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, stream, "Vibra Playback",cmd);		break;	case ABE_FRONTEND_DAI_MODEM:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, stream, "MODEM Playback",cmd);		else			snd_soc_dapm_stream_event(rtd, stream, "MODEM Capture",cmd);		break;	}}static int omap_abe_dai_startup(struct snd_pcm_substream *substream,				  struct snd_soc_dai *dai){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int stream = substream->stream, ret = 0, i;	dev_dbg(dai->dev, "%s: frontend %s %d\n", __func__,			rtd->dai_link->name, dai->id);	mutex_lock(&fe_mutex);	for (i = 0; i < rtd->num_be[stream]; i++) {		struct snd_soc_pcm_runtime *be_rtd = rtd->be_rtd[i][stream];		struct snd_pcm_substream *be_substream =			be_rtd->pcm->streams[stream].substream;		if (be_substream == NULL)			continue;		be_inc_active(rtd->be_rtd[i][stream], stream);		if (be_is_pending(rtd->be_rtd[i][stream], stream)) {			be_rtd->current_fe = dai->id;			ret = snd_soc_pcm_open(be_substream);			if (ret < 0)				goto unwind;			dev_dbg(&rtd->dev, "%s: open %s:%d at %d act %d\n", __func__,				rtd->be_rtd[i][stream]->dai_link->name,				rtd->be_rtd[i][stream]->dai_link->be_id, i,				abe_data.be_active[rtd->be_rtd[i][stream]->dai_link->be_id][stream]);		}	}	ret = abe_fe_startup(substream, dai);	if (ret < 0) {		dev_err(dai->dev,"%s: failed to start FE %d\n", __func__, ret);		goto unwind;	}	dev_dbg(dai->dev,"%s: frontend finished %s %d\n", __func__,			rtd->dai_link->name, dai->id);	mutex_unlock(&fe_mutex);	return 0;unwind:		for (--i; i >= 0; i--) {		struct snd_soc_pcm_runtime *be_rtd = rtd->be_rtd[i][stream];		struct snd_pcm_substream *be_substream =			be_rtd->pcm->streams[stream].substream;		if (be_substream == NULL)			continue;		if (be_is_pending(rtd->be_rtd[i][stream], stream)) {			be_rtd->current_fe = dai->id;			snd_soc_pcm_close(be_substream);			dev_dbg(&rtd->dev, "%s: open-err-close %s:%d at %d act %d\n", __func__,				rtd->be_rtd[i][stream]->dai_link->name,				rtd->be_rtd[i][stream]->dai_link->be_id, i,				abe_data.be_active[rtd->be_rtd[i][stream]->dai_link->be_id][stream]);		}		be_dec_active(rtd->be_rtd[i][stream], stream);	}	mutex_unlock(&fe_mutex);	return ret;}static void omap_abe_dai_shutdown(struct snd_pcm_substream *substream,				    struct snd_soc_dai *dai){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int stream = substream->stream, i;	dev_dbg(dai->dev,"%s: frontend %s \n", __func__, rtd->dai_link->name);	mutex_lock(&fe_mutex);	for (i = 0; i < rtd->num_be[stream]; i++) {		struct snd_soc_pcm_runtime *be_rtd = rtd->be_rtd[i][stream];		struct snd_pcm_substream *be_substream =			be_rtd->pcm->streams[stream].substream;		if (be_substream == NULL)			continue;		if (be_is_pending(rtd->be_rtd[i][stream], stream)) {			be_rtd->current_fe = dai->id;			snd_soc_pcm_close(be_substream);			dev_dbg(&rtd->dev,"%s: close %s:%d at %d act %d\n", __func__,				rtd->be_rtd[i][stream]->dai_link->name,				rtd->be_rtd[i][stream]->dai_link->be_id, i,				abe_data.be_active[rtd->be_rtd[i][stream]->dai_link->be_id][stream]);		}		be_dec_active(rtd->be_rtd[i][stream], stream);	}	abe_fe_shutdown(substream, dai);	abe_be_dapm(rtd, dai->id, stream, SND_SOC_DAPM_STREAM_STOP);	dev_dbg(dai->dev,"%s: frontend %s completed !\n", __func__, rtd->dai_link->name);	mutex_unlock(&fe_mutex);}static int omap_abe_dai_hw_params(struct snd_pcm_substream *substream,				    struct snd_pcm_hw_params *params,				    struct snd_soc_dai *dai){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int stream = substream->stream, i, ret = 0;	struct snd_pcm_hw_params *params_fe;	params_fe = kzalloc(sizeof(struct snd_pcm_hw_params), GFP_KERNEL);	dev_dbg(dai->dev,"%s: frontend %s \n", __func__, rtd->dai_link->name);	memcpy(params_fe, params, sizeof(struct snd_pcm_hw_params));	mutex_lock(&fe_mutex);	for (i = 0; i < rtd->num_be[stream]; i++) {		struct snd_soc_pcm_runtime *be_rtd = rtd->be_rtd[i][stream];		struct snd_pcm_substream *be_substream =			be_rtd->pcm->streams[stream].substream;		if (be_substream == NULL)			continue;		if (be_is_running(rtd->be_rtd[i][stream], stream)) {			be_rtd->current_fe = dai->id;			if (be_rtd->dai_link->be_hw_params_fixup)				ret = be_rtd->dai_link->be_hw_params_fixup(be_rtd, params);			if (ret < 0) {				dev_err(&rtd->dev, "%s: backend hw_params fixup failed %d\n",										__func__, ret);				goto out;			}			ret = snd_soc_pcm_hw_params(be_substream, params);			if (ret < 0) {				dev_err(&rtd->dev, "%s: backend hw_params failed %d\n",						__func__, ret);				goto out;			}		}	}	memcpy(params, params_fe, sizeof(struct snd_pcm_hw_params));	ret = abe_fe_hw_params(substream, params, dai);	if (ret < 0)		dev_err(dai->dev,"%s: frontend hw_params failed\n", __func__);out:	mutex_unlock(&fe_mutex);	kfree(params_fe);	return ret;}static int omap_abe_dai_trigger(struct snd_pcm_substream *substream,				  int cmd, struct snd_soc_dai *dai){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int ret;	dev_dbg(dai->dev,"%s: frontend %s \n", __func__, rtd->dai_link->name);	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)		playback_trigger(substream, cmd);	else		capture_trigger(substream, cmd);	ret = abe_fe_trigger(substream, cmd, dai);	if (ret < 0) {		dev_err(dai->dev,"%s: frontend trigger failed\n", __func__);		return ret;	}	return 0;}static int omap_abe_dai_prepare(struct snd_pcm_substream *substream,				  struct snd_soc_dai *dai){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int stream = substream->stream, ret = 0, i;	dev_dbg(dai->dev,"%s: frontend %s \n", __func__, rtd->dai_link->name);	mutex_lock(&fe_mutex);	for (i = 0; i < rtd->num_be[stream]; i++) {		struct snd_soc_pcm_runtime *be_rtd = rtd->be_rtd[i][stream];		struct snd_pcm_substream *be_substream =			be_rtd->pcm->streams[stream].substream;		if (be_substream == NULL)			continue;		if (be_is_running(rtd->be_rtd[i][stream], stream)) {			be_rtd->current_fe = dai->id;			snd_soc_pcm_prepare(be_substream);		}	}	ret = abe_fe_prepare(substream, dai);	if (ret < 0)		dev_err(dai->dev,"%s: frontend prepare failed\n", __func__);	abe_be_dapm(rtd, dai->id, stream, SND_SOC_DAPM_STREAM_START);	mutex_unlock(&fe_mutex);	return ret;}static int omap_abe_dai_hw_free(struct snd_pcm_substream *substream,				  struct snd_soc_dai *dai){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int stream = substream->stream, ret = 0, i;	dev_dbg(dai->dev,"%s: frontend %s \n", __func__, rtd->dai_link->name);	mutex_lock(&fe_mutex);	ret = abe_fe_hw_free(substream, dai);	if (ret < 0)		dev_err(dai->dev,"%s: frontend hw_free failed\n", __func__);	for (i = 0; i < rtd->num_be[stream]; i++) {		struct snd_soc_pcm_runtime *be_rtd = rtd->be_rtd[i][stream];		struct snd_pcm_substream *be_substream =			be_rtd->pcm->streams[stream].substream;		if (be_substream == NULL)			continue;		if (be_is_running(rtd->be_rtd[i][stream], stream)) {			be_rtd->current_fe = dai->id;			snd_soc_pcm_hw_free(be_substream);		}	}	mutex_unlock(&fe_mutex);	return ret;}static struct snd_soc_dai_ops omap_abe_dai_ops = {	.startup	= omap_abe_dai_startup,	.shutdown	= omap_abe_dai_shutdown,	.hw_params	= omap_abe_dai_hw_params,	.prepare	= omap_abe_dai_prepare,	.hw_free	= omap_abe_dai_hw_free,	.trigger	= omap_abe_dai_trigger,};static void mute_be_capture(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[SNDRV_PCM_STREAM_CAPTURE]; i++) {		be_rtd = rtd->be_rtd[i][SNDRV_PCM_STREAM_CAPTURE];		dev_dbg(&rtd->dev, "%s: be ID=%d\n", __func__, be_rtd->dai_link->be_id);		switch (be_rtd->dai_link->be_id) {		case OMAP_ABE_DAI_PDM_UL:			abe_mute_gain(GAINS_AMIC, GAIN_LEFT_OFFSET);			abe_mute_gain(GAINS_AMIC, GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_BT_VX:		case OMAP_ABE_DAI_MM_FM:		case OMAP_ABE_DAI_MODEM:			break;		case OMAP_ABE_DAI_DMIC0:			abe_mute_gain(GAINS_DMIC1, GAIN_LEFT_OFFSET);			abe_mute_gain(GAINS_DMIC1, GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_DMIC1:			abe_mute_gain(GAINS_DMIC2, GAIN_LEFT_OFFSET);			abe_mute_gain(GAINS_DMIC2, GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_DMIC2:			abe_mute_gain(GAINS_DMIC3, GAIN_LEFT_OFFSET);			abe_mute_gain(GAINS_DMIC3, GAIN_RIGHT_OFFSET);			break;		}	}}static void unmute_be_capture(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[SNDRV_PCM_STREAM_CAPTURE]; i++) {		be_rtd = rtd->be_rtd[i][SNDRV_PCM_STREAM_CAPTURE];		dev_dbg(&rtd->dev, "%s: be ID=%d\n", __func__, be_rtd->dai_link->be_id);		switch (be_rtd->dai_link->be_id) {		case OMAP_ABE_DAI_PDM_UL:			abe_unmute_gain(GAINS_AMIC, GAIN_LEFT_OFFSET);			abe_unmute_gain(GAINS_AMIC, GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_BT_VX:		case OMAP_ABE_DAI_MM_FM:		case OMAP_ABE_DAI_MODEM:			break;		case OMAP_ABE_DAI_DMIC0:			abe_unmute_gain(GAINS_DMIC1, GAIN_LEFT_OFFSET);			abe_unmute_gain(GAINS_DMIC1, GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_DMIC1:			abe_unmute_gain(GAINS_DMIC2, GAIN_LEFT_OFFSET);			abe_unmute_gain(GAINS_DMIC2, GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_DMIC2:			abe_unmute_gain(GAINS_DMIC3, GAIN_LEFT_OFFSET);			abe_unmute_gain(GAINS_DMIC3, GAIN_RIGHT_OFFSET);			break;		}	}}static void mute_be_playback(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[SNDRV_PCM_STREAM_PLAYBACK]; i++) {		be_rtd = rtd->be_rtd[i][SNDRV_PCM_STREAM_PLAYBACK];		dev_dbg(&rtd->dev, "%s: be ID=%d\n", __func__, be_rtd->dai_link->be_id);		switch (be_rtd->dai_link->be_id) {		case OMAP_ABE_DAI_PDM_DL1:			abe_write_gain(GAINS_DL1, MUTE_GAIN, RAMP_5MS,				GAIN_LEFT_OFFSET);			abe_write_gain(GAINS_DL1, MUTE_GAIN, RAMP_5MS,				GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_PDM_DL2:			abe_write_gain(GAINS_DL2, MUTE_GAIN, RAMP_5MS,				GAIN_LEFT_OFFSET);			abe_write_gain(GAINS_DL2, MUTE_GAIN, RAMP_5MS,				GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_BT_VX:						abe_write_gain(GAINS_DL1, MUTE_GAIN, RAMP_5MS,				GAIN_LEFT_OFFSET);			abe_write_gain(GAINS_DL1, MUTE_GAIN, RAMP_5MS,				GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_PDM_VIB:		case OMAP_ABE_DAI_MM_FM:		case OMAP_ABE_DAI_MODEM:			break;		}	}}static void unmute_be_playback(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[SNDRV_PCM_STREAM_PLAYBACK]; i++) {		be_rtd = rtd->be_rtd[i][SNDRV_PCM_STREAM_PLAYBACK];		dev_dbg(&rtd->dev, "%s: be ID=%d\n", __func__, be_rtd->dai_link->be_id);		switch (be_rtd->dai_link->be_id) {		case OMAP_ABE_DAI_PDM_DL1:			abe_write_gain(GAINS_DL1, GAIN_0dB, RAMP_5MS,				GAIN_LEFT_OFFSET);			abe_write_gain(GAINS_DL1, GAIN_0dB, RAMP_5MS,				GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_PDM_DL2:			abe_write_gain(GAINS_DL2, GAIN_0dB, RAMP_5MS,				GAIN_LEFT_OFFSET);			abe_write_gain(GAINS_DL2, GAIN_0dB, RAMP_5MS,				GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_BT_VX:						abe_write_gain(GAINS_DL1, GAIN_0dB, RAMP_5MS,				GAIN_LEFT_OFFSET);			abe_write_gain(GAINS_DL1, GAIN_0dB, RAMP_5MS,				GAIN_RIGHT_OFFSET);			break;		case OMAP_ABE_DAI_PDM_VIB:		case OMAP_ABE_DAI_MM_FM:		case OMAP_ABE_DAI_MODEM:			break;		}	}}static inline void abe_dai_enable_data_transfer(int port){	pr_debug("%s : port %d\n", __func__, port);	if( abe_check_port(port) == 0 ) abe_enable_data_transfer(port);}static void inc_be_ports(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[stream]; i++) {		be_rtd = rtd->be_rtd[i][stream];		if (be_is_running(be_rtd, stream))						trigger_inc_active(be_rtd, stream);	}}static void dec_be_ports(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[stream]; i++) {		be_rtd = rtd->be_rtd[i][stream];		if (be_is_running(be_rtd, stream))						trigger_dec_active(be_rtd, stream);	}}static void enable_be_ports(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	abe_data_format_t format;	int i;	for (i = 0; i < rtd->num_be[stream]; i++) {		be_rtd = rtd->be_rtd[i][stream];		dev_dbg(&rtd->dev, "%s: be ID=%d stream %d active %d\n",				__func__, be_rtd->dai_link->be_id, stream,				be_get_active(be_rtd, stream));		switch (be_rtd->dai_link->be_id) {		case OMAP_ABE_DAI_PDM_DL1:#if 0						if (trigger_is_pending(be_rtd, stream) &&			    pdm_ready(&abe_data))				abe_dai_enable_data_transfer(PDM_DL_PORT);			abe_data.pdm_dl_status[0] = DAI_STARTED;			abe_data.pdm_dl_ref_cnt[0]++;#endif						break;		case OMAP_ABE_DAI_PDM_DL2:#if 0						if (trigger_is_pending(be_rtd, stream) &&			    pdm_ready(&abe_data))				abe_dai_enable_data_transfer(PDM_DL_PORT);			abe_data.pdm_dl_status[1] = DAI_STARTED;			abe_data.pdm_dl_ref_cnt[1]++;#endif						break;		case OMAP_ABE_DAI_PDM_VIB:			if (trigger_is_pending(be_rtd, stream) &&			    pdm_ready(&abe_data))				abe_dai_enable_data_transfer(PDM_DL_PORT);			abe_data.pdm_dl_status[2] = DAI_STARTED;			abe_data.pdm_dl_ref_cnt[2]++;			break;		case OMAP_ABE_DAI_PDM_UL:#if 0						if (trigger_is_pending(be_rtd, stream)) {				abe_dai_enable_data_transfer(PDM_UL_PORT);			}			abe_data.pdm_ul_status = DAI_STARTED;			abe_data.pdm_ul_ref_cnt++;#endif			break;		case OMAP_ABE_DAI_BT_VX:			if (trigger_is_pending(be_rtd, stream)) {				if (stream == SNDRV_PCM_STREAM_PLAYBACK) {										format.f = 8000;					format.samp_format = MONO_RSHIFTED_16;					abe_connect_serial_port(BT_VX_DL_PORT,								&format, MCBSP1_TX);					abe_dai_enable_data_transfer(BT_VX_DL_PORT);				} else {										format.f = 8000;					format.samp_format = MONO_RSHIFTED_16;					abe_connect_serial_port(BT_VX_UL_PORT,								&format, MCBSP1_RX);					abe_dai_enable_data_transfer(BT_VX_UL_PORT);				}			}			break;		case OMAP_ABE_DAI_MM_FM:			if (trigger_is_pending(be_rtd, stream)) {				if (stream == SNDRV_PCM_STREAM_PLAYBACK) {										format.f = 48000;					format.samp_format = STEREO_RSHIFTED_16;					abe_connect_serial_port(MM_EXT_OUT_PORT,								&format, MCBSP2_TX);					abe_dai_enable_data_transfer(MM_EXT_OUT_PORT);				} else {										format.f = 48000;					format.samp_format = STEREO_RSHIFTED_16;					abe_connect_serial_port(MM_EXT_IN_PORT,								&format, MCBSP2_RX);					abe_dai_enable_data_transfer(MM_EXT_IN_PORT);				}			}			break;		case OMAP_ABE_DAI_DMIC0:			if (trigger_is_pending(be_rtd, stream) &&			    dmic_ready(&abe_data))				abe_dai_enable_data_transfer(DMIC_PORT);			abe_data.dmic_status[0] = DAI_STARTED;			break;		case OMAP_ABE_DAI_DMIC1:			if (trigger_is_pending(be_rtd, stream) &&			    dmic_ready(&abe_data))				abe_dai_enable_data_transfer(DMIC_PORT1);			abe_data.dmic_status[1] = DAI_STARTED;			break;		case OMAP_ABE_DAI_DMIC2:			if (trigger_is_pending(be_rtd, stream) &&			    dmic_ready(&abe_data))				abe_dai_enable_data_transfer(DMIC_PORT2);			abe_data.dmic_status[2] = DAI_STARTED;			break;		}	}}static void enable_fe_ports(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	dev_dbg(&rtd->dev, "%s: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, stream);	switch(rtd->cpu_dai->id) {	case ABE_FRONTEND_DAI_MEDIA:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_enable_data_transfer(MM_DL_PORT);		else			abe_enable_data_transfer(MM_UL_PORT);		break;	case ABE_FRONTEND_DAI_LP_MEDIA:		abe_enable_data_transfer(MM_DL_PORT);		break;	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:		if (stream == SNDRV_PCM_STREAM_CAPTURE)			abe_enable_data_transfer(MM_UL2_PORT);		break;	case ABE_FRONTEND_DAI_MODEM:	case ABE_FRONTEND_DAI_VOICE:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_enable_data_transfer(VX_DL_PORT);		else			abe_enable_data_transfer(VX_UL_PORT);		break;	case ABE_FRONTEND_DAI_TONES:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_enable_data_transfer(TONES_DL_PORT);		break;	case ABE_FRONTEND_DAI_VIBRA:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_enable_data_transfer(VIB_DL_PORT);		break;	}}static inline void abe_dai_disable_data_transfer(int port){	if( abe_check_port(port) == 1 ) abe_disable_data_transfer(port);}static void disable_be_ports(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i;	for (i = 0; i < rtd->num_be[stream]; i++) {		be_rtd = rtd->be_rtd[i][stream];		dev_dbg(&rtd->dev, "%s: be ID=%d stream %d active %d\n",				__func__, be_rtd->dai_link->be_id, stream,				be_get_active(be_rtd, stream));		switch (be_rtd->dai_link->be_id) {		case OMAP_ABE_DAI_PDM_DL1:#if 0						abe_data.pdm_dl_status[0] = DAI_STOPPED;			abe_data.pdm_dl_ref_cnt[0]--;			if ( 1				&& trigger_is_pending(be_rtd, stream) 				&& pdm_ready(&abe_data) 				&& abe_data.pdm_dl_ref_cnt[0] == 0 				&& abe_data.pdm_dl_ref_cnt[1] == 0 				&& abe_data.pdm_dl_ref_cnt[2] == 0 			) {				abe_dai_disable_data_transfer(PDM_DL_PORT);			}#endif						break;		case OMAP_ABE_DAI_PDM_DL2:#if 0						abe_data.pdm_dl_status[1] = DAI_STOPPED;			abe_data.pdm_dl_ref_cnt[1]--;			if ( 1				&& trigger_is_pending(be_rtd, stream) 				&& pdm_ready(&abe_data) 				&& abe_data.pdm_dl_ref_cnt[0] == 0 				&& abe_data.pdm_dl_ref_cnt[1] == 0 				&& abe_data.pdm_dl_ref_cnt[2] == 0 			) {				abe_dai_disable_data_transfer(PDM_DL_PORT);			}#endif						break;		case OMAP_ABE_DAI_PDM_VIB:			abe_data.pdm_dl_status[2] = DAI_STOPPED;			abe_data.pdm_dl_ref_cnt[2]--;			if ( 1				&& trigger_is_pending(be_rtd, stream) 				&& pdm_ready(&abe_data) 				&& abe_data.pdm_dl_ref_cnt[0] == 0 				&& abe_data.pdm_dl_ref_cnt[1] == 0 				&& abe_data.pdm_dl_ref_cnt[2] == 0 			)				abe_dai_disable_data_transfer(PDM_VIB_PORT);			break;		case OMAP_ABE_DAI_PDM_UL:#if 0						abe_data.pdm_ul_ref_cnt--;			abe_data.pdm_ul_status = DAI_STOPPED;			if (be_is_pending(be_rtd, stream) && abe_data.pdm_ul_ref_cnt == 0 ) {				abe_dai_disable_data_transfer(PDM_UL_PORT);			}#endif			break;		case OMAP_ABE_DAI_BT_VX:			if (trigger_is_pending(be_rtd, stream)) {				if (stream == SNDRV_PCM_STREAM_PLAYBACK)					abe_dai_disable_data_transfer(BT_VX_DL_PORT);				else					abe_dai_disable_data_transfer(BT_VX_UL_PORT);			}			break;		case OMAP_ABE_DAI_MM_FM:		case OMAP_ABE_DAI_MODEM:			if (trigger_is_pending(be_rtd, stream)) {				if (stream == SNDRV_PCM_STREAM_PLAYBACK)					abe_dai_disable_data_transfer(MM_EXT_OUT_PORT);				else					abe_dai_disable_data_transfer(MM_EXT_IN_PORT);			}		case OMAP_ABE_DAI_DMIC0:			abe_data.dmic_status[0] = DAI_STOPPED;			if (trigger_is_pending(be_rtd, stream) &&			    dmic_ready(&abe_data))				abe_dai_disable_data_transfer(DMIC_PORT);			break;		case OMAP_ABE_DAI_DMIC1:			abe_data.dmic_status[1] = DAI_STOPPED;			if (trigger_is_pending(be_rtd, stream) &&			    dmic_ready(&abe_data))				abe_dai_disable_data_transfer(DMIC_PORT1);			break;		case OMAP_ABE_DAI_DMIC2:			abe_data.dmic_status[2] = DAI_STOPPED;			if (trigger_is_pending(be_rtd, stream) &&			    dmic_ready(&abe_data))				abe_dai_disable_data_transfer(DMIC_PORT2);			break;		}	}}static void disable_fe_ports(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	dev_dbg(&rtd->dev, "%s: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, stream);	switch(rtd->cpu_dai->id) {	case ABE_FRONTEND_DAI_MEDIA:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_disable_data_transfer(MM_DL_PORT);		else			abe_disable_data_transfer(MM_UL_PORT);		break;	case ABE_FRONTEND_DAI_LP_MEDIA:		abe_disable_data_transfer(MM_DL_PORT);		break;	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:		if (stream == SNDRV_PCM_STREAM_CAPTURE)			abe_disable_data_transfer(MM_UL2_PORT);		break;	case ABE_FRONTEND_DAI_MODEM:	case ABE_FRONTEND_DAI_VOICE:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_disable_data_transfer(VX_DL_PORT);		else			abe_disable_data_transfer(VX_UL_PORT);		break;	case ABE_FRONTEND_DAI_TONES:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_disable_data_transfer(TONES_DL_PORT);		break;	case ABE_FRONTEND_DAI_VIBRA:		if (stream == SNDRV_PCM_STREAM_PLAYBACK)			abe_disable_data_transfer(VIB_DL_PORT);		break;	}}static void mute_fe_port(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	dev_dbg(&rtd->dev, "%s: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, stream);	switch(rtd->cpu_dai->id) {	case ABE_FRONTEND_DAI_MEDIA:	case ABE_FRONTEND_DAI_LP_MEDIA:		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL2][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_mute_gain(MIXDL2, MIX_DL2_INPUT_MM_DL);		}		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL1][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_mute_gain(MIXDL1, MIX_DL1_INPUT_MM_DL);		}		break;	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:		break;	case ABE_FRONTEND_DAI_VOICE:		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL2][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_mute_gain(MIXDL2, MIX_DL2_INPUT_VX_DL);		}		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL1][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_mute_gain(MIXDL1, MIX_DL1_INPUT_VX_DL);		}		break;	case ABE_FRONTEND_DAI_TONES:		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL2][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_mute_gain(MIXDL2, MIX_DL2_INPUT_TONES);		}		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL1][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_mute_gain(MIXDL1, MIX_DL1_INPUT_TONES);		}		break;	case ABE_FRONTEND_DAI_VIBRA:		break;	}}static void unmute_fe_port(struct snd_pcm_substream *substream, int stream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	dev_dbg(&rtd->dev, "%s: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, stream);	switch(rtd->cpu_dai->id) {	case ABE_FRONTEND_DAI_MEDIA:	case ABE_FRONTEND_DAI_LP_MEDIA:		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL2][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_unmute_gain(MIXDL2, MIX_DL2_INPUT_MM_DL);		}		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL1][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_unmute_gain(MIXDL1, MIX_DL1_INPUT_MM_DL);		}		break;	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:		break;	case ABE_FRONTEND_DAI_VOICE:		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL2][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_unmute_gain(MIXDL2, MIX_DL2_INPUT_VX_DL);		}		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL1][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_unmute_gain(MIXDL1, MIX_DL1_INPUT_VX_DL);		}		break;	case ABE_FRONTEND_DAI_TONES:		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL2][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_unmute_gain(MIXDL2, MIX_DL2_INPUT_TONES);		}		if (abe_data.be_active[OMAP_ABE_DAI_PDM_DL1][SNDRV_PCM_STREAM_PLAYBACK]) {			abe_unmute_gain(MIXDL1, MIX_DL1_INPUT_TONES);		}		break;	case ABE_FRONTEND_DAI_VIBRA:		break;	}}static void trigger_be_ports(struct snd_pcm_substream *substream, int cmd){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_pcm_runtime *be_rtd;	int i, stream = substream->stream;	for (i = 0; i < rtd->num_be[stream]; i++) {		be_rtd = rtd->be_rtd[i][stream];		dev_dbg(&rtd->dev, "%s: be ID=%d cmd %d act %d\n",				__func__, be_rtd->dai_link->be_id, cmd,				abe_data.be_active[be_rtd->dai_link->be_id][stream]);		switch (cmd) {		case SNDRV_PCM_TRIGGER_START:		case SNDRV_PCM_TRIGGER_STOP:			if (be_is_running(be_rtd, stream) &&			    trigger_is_pending(be_rtd, stream))					snd_soc_dai_trigger(substream, cmd,							be_rtd->cpu_dai);			break;		default:			if (be_is_running(be_rtd, stream))				snd_soc_dai_trigger(substream, cmd,							be_rtd->cpu_dai);			break;		}	}}static void capture_trigger(struct snd_pcm_substream *substream, int cmd){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	dev_dbg(&rtd->dev, "%s-start: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, substream->stream);	switch (cmd) {	case SNDRV_PCM_TRIGGER_START:				mute_be_capture(substream);		inc_be_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		enable_be_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		udelay(500);		trigger_be_ports(substream, cmd);		enable_fe_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		unmute_be_capture(substream);		break;	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:				enable_fe_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		break;	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:				disable_fe_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		break;	case SNDRV_PCM_TRIGGER_STOP:				disable_fe_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		disable_be_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		udelay(500);		trigger_be_ports(substream, cmd);		dec_be_ports(substream, SNDRV_PCM_STREAM_CAPTURE);		break;	default:		break;	}	dev_dbg(&rtd->dev, "%s - finish: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, substream->stream);}static void playback_trigger(struct snd_pcm_substream *substream, int cmd){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	dev_dbg(&rtd->dev, "%s-start: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, substream->stream);	switch (cmd) {	case SNDRV_PCM_TRIGGER_START:				mute_be_playback(substream);		inc_be_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		enable_be_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		udelay(500);		trigger_be_ports(substream, cmd);		unmute_be_playback(substream);		enable_fe_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		unmute_fe_port(substream, SNDRV_PCM_STREAM_PLAYBACK);		break;	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:				enable_fe_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		unmute_fe_port(substream, SNDRV_PCM_STREAM_PLAYBACK);		break;	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:				disable_fe_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		mute_fe_port(substream, SNDRV_PCM_STREAM_PLAYBACK);		break;	case SNDRV_PCM_TRIGGER_STOP:				disable_fe_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		mute_fe_port(substream, SNDRV_PCM_STREAM_PLAYBACK);		disable_be_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		udelay(500);		trigger_be_ports(substream, cmd);		dec_be_ports(substream, SNDRV_PCM_STREAM_PLAYBACK);		break;	default:		break;	}	dev_dbg(&rtd->dev, "%s - finish: fe ID=%d stream %d\n",			__func__, rtd->cpu_dai->id, substream->stream);}static int omap_abe_dai_probe(struct snd_soc_dai *dai){	snd_soc_dai_set_drvdata(dai, &abe_data);	abe_data.dmic_ref_cnt[0] = 0;	abe_data.dmic_ref_cnt[1] = 0;	abe_data.dmic_ref_cnt[2] = 0;	abe_data.pdm_dl_ref_cnt[0] = 0;	abe_data.pdm_dl_ref_cnt[1] = 0;	abe_data.pdm_dl_ref_cnt[2] = 0;	abe_data.pdm_ul_ref_cnt = 0;		abe_data.workqueue = create_singlethread_workqueue("omap-abe");	if (abe_data.workqueue == NULL)		return -ENOMEM;	return 0;}static int omap_abe_dai_remove(struct snd_soc_dai *dai){	destroy_workqueue(abe_data.workqueue);	return 0;}static struct snd_soc_dai_driver omap_abe_dai[] = {	{			.name = "MultiMedia1",		.probe = omap_abe_dai_probe,		.remove = omap_abe_dai_remove,		.playback = {			.stream_name = "MultiMedia1 Playback",			.channels_min = 1,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_48000,			.formats = OMAP_ABE_FORMATS,		},		.capture = {			.stream_name = "MultiMedia1 Capture",			.channels_min = 2,			.channels_max = 8,			.rates = SNDRV_PCM_RATE_48000,			.formats = OMAP_ABE_FORMATS,		},		.ops = &omap_abe_dai_ops,	},	{			.name = "MultiMedia2",		.capture = {			.stream_name = "MultiMedia2 Capture",			.channels_min = 1,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_48000,			.formats = OMAP_ABE_FORMATS,		},		.ops = &omap_abe_dai_ops,	},	{			.name = "Voice",		.playback = {			.stream_name = "Voice Playback",			.channels_min = 1,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,			.formats = OMAP_ABE_FORMATS,		},		.capture = {			.stream_name = "Voice Capture",			.channels_min = 1,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,			.formats = OMAP_ABE_FORMATS,		},		.ops = &omap_abe_dai_ops,	},	{			.name = "Tones",		.playback = {			.stream_name = "Tones Playback",			.channels_min = 1,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_48000,			.formats = OMAP_ABE_FORMATS,		},		.ops = &omap_abe_dai_ops,	},	{			.name = "Vibra",		.playback = {			.stream_name = "Vibra Playback",			.channels_min = 2,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_CONTINUOUS,			.formats = OMAP_ABE_FORMATS,		},		.ops = &omap_abe_dai_ops,	},	{			.name = "MODEM",		.playback = {			.stream_name = "Voice Playback",			.channels_min = 1,			.channels_max = 1,			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,			.formats = OMAP_ABE_FORMATS | SNDRV_PCM_FMTBIT_S16_LE,		},		.capture = {			.stream_name = "Voice Capture",			.channels_min = 1,			.channels_max = 1,			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,			.formats = OMAP_ABE_FORMATS | SNDRV_PCM_FMTBIT_S16_LE,		},		.ops = &omap_abe_dai_ops,	},	{			.name = "MultiMedia1 LP",		.playback = {			.stream_name = "MultiMedia1 LP Playback",			.channels_min = 2,			.channels_max = 2,			.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,			.formats = OMAP_ABE_FORMATS | SNDRV_PCM_FMTBIT_S16_LE,		},		.ops = &omap_abe_dai_ops,	},};static int __devinit omap_abe_probe(struct platform_device *pdev){	return snd_soc_register_dais(&pdev->dev, omap_abe_dai,			ARRAY_SIZE(omap_abe_dai));}static int __devexit omap_abe_remove(struct platform_device *pdev){	snd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(omap_abe_dai));	return 0;}static struct platform_driver omap_abe_driver = {	.driver = {		.name = "omap-abe-dai",		.owner = THIS_MODULE,	},	.probe = omap_abe_probe,	.remove = __devexit_p(omap_abe_remove),};static int __init omap_abe_init(void){	return platform_driver_register(&omap_abe_driver);}module_init(omap_abe_init);static void __exit omap_abe_exit(void){	platform_driver_unregister(&omap_abe_driver);}module_exit(omap_abe_exit);MODULE_AUTHOR("Liam Girdwood <lrg@slimlogic.co.uk>");MODULE_DESCRIPTION("OMAP ABE SoC Interface");MODULE_LICENSE("GPL");