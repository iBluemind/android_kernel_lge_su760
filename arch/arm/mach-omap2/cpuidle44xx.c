#include <linux/sched.h>#include <linux/cpuidle.h>#include <linux/clockchips.h>#include <linux/gpio.h>#include <linux/delay.h>#include <mach/omap4-common.h>#include <mach/omap4-wakeupgen.h>#include "pm.h"#include "prm.h"#include "pm.h"#include "cm.h"#include "cm-regbits-44xx.h"#include "clock.h"#ifdef CONFIG_CPU_IDLE#ifdef DEBUG_CPUIDLEstatic int n_print_count=0;static int old_c_status=0;static char old_c_name[CPUIDLE_NAME_LEN]= {0,};#endif #define OMAP4_MAX_STATES	4#define OMAP4_STATE_C1		0#define OMAP4_STATE_C2		1#define OMAP4_STATE_C3		2#define OMAP4_STATE_C4		3struct omap4_processor_cx {	u8 valid;	u8 type;	u32 sleep_latency;	u32 wakeup_latency;	u32 cpu0_state;	u32 cpu1_state;	u32 mpu_state;	u32 mpu_logic_state;	u32 core_state;	u32 core_logic_state;	u32 threshold;	u32 flags;	const char *desc;};struct omap4_processor_cx omap4_power_states[OMAP4_MAX_STATES];struct omap4_processor_cx current_cx_state;struct powerdomain *mpu_pd, *cpu1_pd, *core_pd;static struct cpuidle_params cpuidle_params_table[] = {		{1,	2,	2,	5},		{1,	140,	160,	300},		{1,	1516,	3230,	15000},		{1,	1644,	3298,	39000},};static int omap4_idle_bm_check(void){	if (!omap4_can_sleep())		return 1;	return 0;}static void pl310flush(void){    u32 temp = 0;    u32 vaddr = OMAP44XX_L2CACHE_BASE + 0x730;    omap_writel(temp,vaddr);    while((omap_readl(vaddr) & 0x01))    		;    temp = omap_readl(vaddr);    omap_writel(temp,vaddr);}static int omap4_enter_idle(struct cpuidle_device *dev,			struct cpuidle_state *state){	struct omap4_processor_cx *cx = cpuidle_get_statedata(state);	struct timespec ts_preidle, ts_postidle, ts_idle;	u32 cpu1_state;	int cpu_id = smp_processor_id();	getnstimeofday(&ts_preidle);	local_irq_disable();	local_fiq_disable();	if (dev->cpu) {		wmb();		pl310flush();		do_wfi();		goto return_sleep_time;	}	if (num_online_cpus() > 1) {		wmb();		pl310flush();		do_wfi();		goto return_sleep_time;	}	cpu1_state = pwrdm_read_pwrst(cpu1_pd);	if (cpu1_state != PWRDM_POWER_OFF) {		wmb();		pl310flush();		do_wfi();		goto return_sleep_time;	}	if (cx->type > OMAP4_STATE_C1)		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu_id);#ifdef DEBUG_CPUIDLE	if ((old_c_status != cx->type) || strcmp(old_c_name, state->name) != 0)	{			if(n_print_count % 100 == 0) 				printk("C-name=%s, C-status=%d\n", state->name, cx->type);			n_print_count++; 	}	old_c_status = cx->type;	strcpy(old_c_name, state->name);#endif#ifdef CONFIG_PM_DEBUG	pwrdm_pre_transition();#endif	pwrdm_set_logic_retst(mpu_pd, cx->mpu_logic_state);	omap4_set_pwrdm_state(mpu_pd, cx->mpu_state);	pwrdm_set_logic_retst(core_pd, cx->core_logic_state);	omap4_set_pwrdm_state(core_pd, cx->core_state);	pl310flush();	omap4_enter_sleep(dev->cpu, cx->cpu0_state);	omap4_set_pwrdm_state(mpu_pd, PWRDM_POWER_ON);	omap4_set_pwrdm_state(core_pd, PWRDM_POWER_ON);#ifdef CONFIG_PM_DEBUG	pwrdm_post_transition();#endif	if (cx->type > OMAP4_STATE_C1)		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu_id);return_sleep_time:	getnstimeofday(&ts_postidle);	ts_idle = timespec_sub(ts_postidle, ts_preidle);	local_irq_enable();	local_fiq_enable();	return ts_idle.tv_nsec / NSEC_PER_USEC + ts_idle.tv_sec * USEC_PER_SEC;;}static int omap4_enter_idle_bm(struct cpuidle_device *dev,			       struct cpuidle_state *state){	if ((state->flags & CPUIDLE_FLAG_CHECK_BM) && omap4_idle_bm_check()) {		BUG_ON(!dev->safe_state);		state = dev->safe_state;	}	dev->last_state = state;	return omap4_enter_idle(dev, state);}DEFINE_PER_CPU(struct cpuidle_device, omap4_idle_dev);void omap_init_power_states(void){	omap4_power_states[OMAP4_STATE_C1].valid =			cpuidle_params_table[OMAP4_STATE_C1].valid;	omap4_power_states[OMAP4_STATE_C1].type = OMAP4_STATE_C1;	omap4_power_states[OMAP4_STATE_C1].sleep_latency =			cpuidle_params_table[OMAP4_STATE_C1].sleep_latency;	omap4_power_states[OMAP4_STATE_C1].wakeup_latency =			cpuidle_params_table[OMAP4_STATE_C1].wake_latency;	omap4_power_states[OMAP4_STATE_C1].threshold =			cpuidle_params_table[OMAP4_STATE_C1].threshold;	omap4_power_states[OMAP4_STATE_C1].cpu0_state = PWRDM_POWER_ON;	omap4_power_states[OMAP4_STATE_C1].cpu1_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C1].mpu_state = PWRDM_POWER_ON;	omap4_power_states[OMAP4_STATE_C1].mpu_logic_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C1].core_state = PWRDM_POWER_ON;	omap4_power_states[OMAP4_STATE_C1].core_logic_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C1].flags = CPUIDLE_FLAG_TIME_VALID;	omap4_power_states[OMAP4_STATE_C1].desc = "MPU ON + CORE ON";	omap4_power_states[OMAP4_STATE_C2].valid =			cpuidle_params_table[OMAP4_STATE_C2].valid;	omap4_power_states[OMAP4_STATE_C2].type = OMAP4_STATE_C2;	omap4_power_states[OMAP4_STATE_C2].sleep_latency =			cpuidle_params_table[OMAP4_STATE_C2].sleep_latency;	omap4_power_states[OMAP4_STATE_C2].wakeup_latency =			cpuidle_params_table[OMAP4_STATE_C2].wake_latency;	omap4_power_states[OMAP4_STATE_C2].threshold =			cpuidle_params_table[OMAP4_STATE_C2].threshold;	omap4_power_states[OMAP4_STATE_C2].cpu0_state = PWRDM_POWER_INACTIVE;	omap4_power_states[OMAP4_STATE_C2].cpu1_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C2].mpu_state = PWRDM_POWER_INACTIVE;	omap4_power_states[OMAP4_STATE_C2].mpu_logic_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C2].core_state = PWRDM_POWER_INACTIVE;	omap4_power_states[OMAP4_STATE_C2].core_logic_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C2].flags = CPUIDLE_FLAG_TIME_VALID |		CPUIDLE_FLAG_CHECK_BM;	omap4_power_states[OMAP4_STATE_C2].desc = "MPU INA + CORE INA";	omap4_power_states[OMAP4_STATE_C3].valid =			cpuidle_params_table[OMAP4_STATE_C3].valid;	omap4_power_states[OMAP4_STATE_C3].type = OMAP4_STATE_C3;	omap4_power_states[OMAP4_STATE_C3].sleep_latency =			cpuidle_params_table[OMAP4_STATE_C3].sleep_latency;	omap4_power_states[OMAP4_STATE_C3].wakeup_latency =			cpuidle_params_table[OMAP4_STATE_C3].wake_latency;	omap4_power_states[OMAP4_STATE_C3].threshold =			cpuidle_params_table[OMAP4_STATE_C3].threshold;	omap4_power_states[OMAP4_STATE_C3].cpu0_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C3].cpu1_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C3].mpu_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C3].mpu_logic_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C3].core_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C3].core_logic_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C3].flags = CPUIDLE_FLAG_TIME_VALID |		CPUIDLE_FLAG_CHECK_BM;	omap4_power_states[OMAP4_STATE_C3].desc = "MPU CSWR + CORE OSWR";	omap4_power_states[OMAP4_STATE_C4].valid =			cpuidle_params_table[OMAP4_STATE_C4].valid;	omap4_power_states[OMAP4_STATE_C4].type = OMAP4_STATE_C4;	omap4_power_states[OMAP4_STATE_C4].sleep_latency =			cpuidle_params_table[OMAP4_STATE_C4].sleep_latency;	omap4_power_states[OMAP4_STATE_C4].wakeup_latency =			cpuidle_params_table[OMAP4_STATE_C4].wake_latency;	omap4_power_states[OMAP4_STATE_C4].threshold =			cpuidle_params_table[OMAP4_STATE_C4].threshold;	omap4_power_states[OMAP4_STATE_C4].cpu0_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C4].cpu1_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C4].mpu_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C4].mpu_logic_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C4].core_state = PWRDM_POWER_RET;	omap4_power_states[OMAP4_STATE_C4].core_logic_state = PWRDM_POWER_OFF;	omap4_power_states[OMAP4_STATE_C4].flags = CPUIDLE_FLAG_TIME_VALID |		CPUIDLE_FLAG_CHECK_BM;	omap4_power_states[OMAP4_STATE_C4].desc = "MPU OSWR + CORE OSWR";}struct cpuidle_driver omap4_idle_driver = {	.name =		"omap4_idle",	.owner =	THIS_MODULE,};int __init omap4_idle_init(void){	int cpu_id, i, count = 0;	struct omap4_processor_cx *cx;	struct cpuidle_state *state;	struct cpuidle_device *dev;	mpu_pd = pwrdm_lookup("mpu_pwrdm");	cpu1_pd = pwrdm_lookup("cpu1_pwrdm");	core_pd = pwrdm_lookup("core_pwrdm");	omap_init_power_states();	cpuidle_register_driver(&omap4_idle_driver);	for_each_cpu(cpu_id, cpu_online_mask) {		pr_err("CPUidle for CPU%d registered\n", cpu_id);		dev = &per_cpu(omap4_idle_dev, cpu_id);		dev->cpu = cpu_id;		count = 0;		for (i = OMAP4_STATE_C1; i < OMAP4_MAX_STATES; i++) {			cx = &omap4_power_states[i];			state = &dev->states[count];			if (!cx->valid)				continue;			cpuidle_set_statedata(state, cx);			state->exit_latency = cx->sleep_latency +							cx->wakeup_latency;			state->target_residency = cx->threshold;			state->flags = cx->flags;			if (cx->type == OMAP4_STATE_C1)				dev->safe_state = state;			state->enter = (state->flags & CPUIDLE_FLAG_CHECK_BM) ?					omap4_enter_idle_bm : omap4_enter_idle;			sprintf(state->name, "C%d", count+1);			strncpy(state->desc, cx->desc, CPUIDLE_DESC_LEN);			count++;		}		if (!count)			return -EINVAL;		dev->state_count = count;		if (cpuidle_register_device(dev)) {			printk(KERN_ERR "%s: CPUidle register device failed\n",				__func__);			return -EIO;		}	}	return 0;}#elseint __init omap4_idle_init(void){	return 0;}#endif